{"ast":null,"code":"import Utils from '../../../utils/utils';\nexport default function (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n  const {\n    params,\n    touches,\n    rtlTranslate: rtl,\n    $wrapperEl,\n    slidesGrid,\n    snapGrid\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n\n  data.allowTouchCallbacks = false;\n\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  } // Return Grab Cursor\n\n\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  } // Time diff\n\n\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click\n\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n\n    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n  let currentPos;\n\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        } // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n\n\n        if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n\n        newPosition = -newPosition;\n      }\n\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      } // Fix duration\n\n\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n\n    return;\n  } // Find current slide\n\n\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n\n  for (let i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {\n    const increment = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  } // Find current slide size\n\n\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > 1 - params.longSwipesRatio) swiper.slideTo(stopIndex + increment);else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}","map":{"version":3,"sources":["/Users/mac2/Desktop/git/thedigitalmoney/digital-money/node_modules/swiper/src/components/core/events/onTouchEnd.js"],"names":["Utils","event","swiper","data","touchEventsData","params","touches","rtlTranslate","rtl","$wrapperEl","slidesGrid","snapGrid","e","originalEvent","allowTouchCallbacks","emit","isTouched","isMoved","grabCursor","setGrabCursor","startMoving","allowSlideNext","allowSlidePrev","touchEndTime","now","timeDiff","touchStartTime","allowClick","updateClickedSlide","lastClickTime","nextTick","destroyed","swipeDirection","diff","currentTranslate","startTranslate","currentPos","followFinger","translate","cssMode","freeMode","minTranslate","slideTo","activeIndex","maxTranslate","slides","length","freeModeMomentum","velocities","lastMoveEvent","pop","velocityEvent","distance","position","time","velocity","Math","abs","freeModeMinimumVelocity","freeModeMomentumVelocityRatio","momentumDuration","freeModeMomentumRatio","momentumDistance","newPosition","doBounce","afterBouncePosition","bounceAmount","freeModeMomentumBounceRatio","needsLoopFix","freeModeMomentumBounce","allowMomentumBounce","loop","centeredSlides","freeModeSticky","nextSlide","j","once","loopFix","moveDistance","currentSlideSize","slidesSizesGrid","speed","slideToClosest","updateProgress","setTransition","setTranslate","transitionStart","animating","transitionEnd","updateActiveIndex","updateSlidesClasses","longSwipesMs","stopIndex","groupSize","i","slidesPerGroupSkip","slidesPerGroup","increment","ratio","longSwipes","longSwipesRatio","shortSwipes","isNavButtonTarget","navigation","target","nextEl","prevEl"],"mappings":"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","sourcesContent":["import Utils from '../../../utils/utils';\n\nexport default function (event) {\n  const swiper = this;\n  const data = swiper.touchEventsData;\n\n  const {\n    params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,\n  } = swiper;\n  let e = event;\n  if (e.originalEvent) e = e.originalEvent;\n  if (data.allowTouchCallbacks) {\n    swiper.emit('touchEnd', e);\n  }\n  data.allowTouchCallbacks = false;\n  if (!data.isTouched) {\n    if (data.isMoved && params.grabCursor) {\n      swiper.setGrabCursor(false);\n    }\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  // Return Grab Cursor\n  if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {\n    swiper.setGrabCursor(false);\n  }\n\n  // Time diff\n  const touchEndTime = Utils.now();\n  const timeDiff = touchEndTime - data.touchStartTime;\n\n  // Tap, doubleTap, Click\n  if (swiper.allowClick) {\n    swiper.updateClickedSlide(e);\n    swiper.emit('tap click', e);\n    if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {\n      swiper.emit('doubleTap doubleClick', e);\n    }\n  }\n\n  data.lastClickTime = Utils.now();\n  Utils.nextTick(() => {\n    if (!swiper.destroyed) swiper.allowClick = true;\n  });\n\n  if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {\n    data.isTouched = false;\n    data.isMoved = false;\n    data.startMoving = false;\n    return;\n  }\n  data.isTouched = false;\n  data.isMoved = false;\n  data.startMoving = false;\n\n  let currentPos;\n  if (params.followFinger) {\n    currentPos = rtl ? swiper.translate : -swiper.translate;\n  } else {\n    currentPos = -data.currentTranslate;\n  }\n\n  if (params.cssMode) {\n    return;\n  }\n\n  if (params.freeMode) {\n    if (currentPos < -swiper.minTranslate()) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (currentPos > -swiper.maxTranslate()) {\n      if (swiper.slides.length < snapGrid.length) {\n        swiper.slideTo(snapGrid.length - 1);\n      } else {\n        swiper.slideTo(swiper.slides.length - 1);\n      }\n      return;\n    }\n\n    if (params.freeModeMomentum) {\n      if (data.velocities.length > 1) {\n        const lastMoveEvent = data.velocities.pop();\n        const velocityEvent = data.velocities.pop();\n\n        const distance = lastMoveEvent.position - velocityEvent.position;\n        const time = lastMoveEvent.time - velocityEvent.time;\n        swiper.velocity = distance / time;\n        swiper.velocity /= 2;\n        if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {\n          swiper.velocity = 0;\n        }\n        // this implies that the user stopped moving a finger then released.\n        // There would be no events with distance zero, so the last event is stale.\n        if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {\n          swiper.velocity = 0;\n        }\n      } else {\n        swiper.velocity = 0;\n      }\n      swiper.velocity *= params.freeModeMomentumVelocityRatio;\n\n      data.velocities.length = 0;\n      let momentumDuration = 1000 * params.freeModeMomentumRatio;\n      const momentumDistance = swiper.velocity * momentumDuration;\n\n      let newPosition = swiper.translate + momentumDistance;\n      if (rtl) newPosition = -newPosition;\n\n      let doBounce = false;\n      let afterBouncePosition;\n      const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;\n      let needsLoopFix;\n      if (newPosition < swiper.maxTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition + swiper.maxTranslate() < -bounceAmount) {\n            newPosition = swiper.maxTranslate() - bounceAmount;\n          }\n          afterBouncePosition = swiper.maxTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.maxTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (newPosition > swiper.minTranslate()) {\n        if (params.freeModeMomentumBounce) {\n          if (newPosition - swiper.minTranslate() > bounceAmount) {\n            newPosition = swiper.minTranslate() + bounceAmount;\n          }\n          afterBouncePosition = swiper.minTranslate();\n          doBounce = true;\n          data.allowMomentumBounce = true;\n        } else {\n          newPosition = swiper.minTranslate();\n        }\n        if (params.loop && params.centeredSlides) needsLoopFix = true;\n      } else if (params.freeModeSticky) {\n        let nextSlide;\n        for (let j = 0; j < snapGrid.length; j += 1) {\n          if (snapGrid[j] > -newPosition) {\n            nextSlide = j;\n            break;\n          }\n        }\n\n        if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {\n          newPosition = snapGrid[nextSlide];\n        } else {\n          newPosition = snapGrid[nextSlide - 1];\n        }\n        newPosition = -newPosition;\n      }\n      if (needsLoopFix) {\n        swiper.once('transitionEnd', () => {\n          swiper.loopFix();\n        });\n      }\n      // Fix duration\n      if (swiper.velocity !== 0) {\n        if (rtl) {\n          momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);\n        } else {\n          momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);\n        }\n        if (params.freeModeSticky) {\n          // If freeModeSticky is active and the user ends a swipe with a slow-velocity\n          // event, then durations can be 20+ seconds to slide one (or zero!) slides.\n          // It's easy to see this when simulating touch with mouse events. To fix this,\n          // limit single-slide swipes to the default slide duration. This also has the\n          // nice side effect of matching slide speed if the user stopped moving before\n          // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.\n          // For faster swipes, also apply limits (albeit higher ones).\n          const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);\n          const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];\n          if (moveDistance < currentSlideSize) {\n            momentumDuration = params.speed;\n          } else if (moveDistance < 2 * currentSlideSize) {\n            momentumDuration = params.speed * 1.5;\n          } else {\n            momentumDuration = params.speed * 2.5;\n          }\n        }\n      } else if (params.freeModeSticky) {\n        swiper.slideToClosest();\n        return;\n      }\n\n      if (params.freeModeMomentumBounce && doBounce) {\n        swiper.updateProgress(afterBouncePosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        swiper.animating = true;\n        $wrapperEl.transitionEnd(() => {\n          if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;\n          swiper.emit('momentumBounce');\n\n          swiper.setTransition(params.speed);\n          swiper.setTranslate(afterBouncePosition);\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        });\n      } else if (swiper.velocity) {\n        swiper.updateProgress(newPosition);\n        swiper.setTransition(momentumDuration);\n        swiper.setTranslate(newPosition);\n        swiper.transitionStart(true, swiper.swipeDirection);\n        if (!swiper.animating) {\n          swiper.animating = true;\n          $wrapperEl.transitionEnd(() => {\n            if (!swiper || swiper.destroyed) return;\n            swiper.transitionEnd();\n          });\n        }\n      } else {\n        swiper.updateProgress(newPosition);\n      }\n\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    } else if (params.freeModeSticky) {\n      swiper.slideToClosest();\n      return;\n    }\n\n    if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {\n      swiper.updateProgress();\n      swiper.updateActiveIndex();\n      swiper.updateSlidesClasses();\n    }\n    return;\n  }\n\n  // Find current slide\n  let stopIndex = 0;\n  let groupSize = swiper.slidesSizesGrid[0];\n  for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {\n    const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);\n    if (typeof slidesGrid[i + increment] !== 'undefined') {\n      if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {\n        stopIndex = i;\n        groupSize = slidesGrid[i + increment] - slidesGrid[i];\n      }\n    } else if (currentPos >= slidesGrid[i]) {\n      stopIndex = i;\n      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];\n    }\n  }\n\n  // Find current slide size\n  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;\n  const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);\n\n  if (timeDiff > params.longSwipesMs) {\n    // Long touches\n    if (!params.longSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    if (swiper.swipeDirection === 'next') {\n      if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n    if (swiper.swipeDirection === 'prev') {\n      if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);\n      else swiper.slideTo(stopIndex);\n    }\n  } else {\n    // Short swipes\n    if (!params.shortSwipes) {\n      swiper.slideTo(swiper.activeIndex);\n      return;\n    }\n    const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);\n    if (!isNavButtonTarget) {\n      if (swiper.swipeDirection === 'next') {\n        swiper.slideTo(stopIndex + increment);\n      }\n      if (swiper.swipeDirection === 'prev') {\n        swiper.slideTo(stopIndex);\n      }\n    } else if (e.target === swiper.navigation.nextEl) {\n      swiper.slideTo(stopIndex + increment);\n    } else {\n      swiper.slideTo(stopIndex);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}