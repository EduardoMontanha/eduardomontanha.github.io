{"ast":null,"code":"export default function (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n  const {\n    params,\n    snapGrid,\n    slidesGrid,\n    previousIndex,\n    activeIndex,\n    rtlTranslate: rtl,\n    wrapperEl\n  } = swiper;\n\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  const translate = -snapGrid[snapIndex]; // Update progress\n\n  swiper.updateProgress(translate); // Normalize slideIndex\n\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  } // Directions locks\n\n\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';else if (slideIndex < activeIndex) direction = 'prev';else direction = 'reset'; // Update Index\n\n  if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {\n    swiper.updateActiveIndex(slideIndex); // Update Height\n\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n\n    swiper.updateSlidesClasses();\n\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n\n    return false;\n  }\n\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -translate,\n          behavior: 'smooth'\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;\n      }\n    }\n\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n\n    if (!swiper.animating) {\n      swiper.animating = true;\n\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/mac2/Desktop/git/thedigitalmoney/digital-money/node_modules/swiper/src/components/core/slide/slideTo.js"],"names":["index","speed","params","runCallbacks","internal","swiper","slideIndex","snapGrid","slidesGrid","previousIndex","activeIndex","rtlTranslate","rtl","wrapperEl","animating","preventInteractionOnTransition","skip","Math","min","slidesPerGroupSkip","snapIndex","floor","slidesPerGroup","length","initialSlide","emit","translate","updateProgress","normalizeSlideIndex","i","initialized","allowSlideNext","minTranslate","allowSlidePrev","maxTranslate","direction","updateActiveIndex","autoHeight","updateAutoHeight","updateSlidesClasses","effect","setTranslate","transitionStart","transitionEnd","cssMode","isH","isHorizontal","scrollTo","behavior","setTransition","onSlideToWrapperTransitionEnd","e","destroyed","target","$wrapperEl","removeEventListener","addEventListener"],"mappings":"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","sourcesContent":["export default function (index = 0, speed = this.params.speed, runCallbacks = true, internal) {\n  const swiper = this;\n  let slideIndex = index;\n  if (slideIndex < 0) slideIndex = 0;\n\n  const {\n    params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,\n  } = swiper;\n  if (swiper.animating && params.preventInteractionOnTransition) {\n    return false;\n  }\n\n  const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);\n  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);\n  if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;\n\n  if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {\n    swiper.emit('beforeSlideChangeStart');\n  }\n\n  const translate = -snapGrid[snapIndex];\n\n  // Update progress\n  swiper.updateProgress(translate);\n\n  // Normalize slideIndex\n  if (params.normalizeSlideIndex) {\n    for (let i = 0; i < slidesGrid.length; i += 1) {\n      if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {\n        slideIndex = i;\n      }\n    }\n  }\n  // Directions locks\n  if (swiper.initialized && slideIndex !== activeIndex) {\n    if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {\n      return false;\n    }\n    if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {\n      if ((activeIndex || 0) !== slideIndex) return false;\n    }\n  }\n\n  let direction;\n  if (slideIndex > activeIndex) direction = 'next';\n  else if (slideIndex < activeIndex) direction = 'prev';\n  else direction = 'reset';\n\n\n  // Update Index\n  if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {\n    swiper.updateActiveIndex(slideIndex);\n    // Update Height\n    if (params.autoHeight) {\n      swiper.updateAutoHeight();\n    }\n    swiper.updateSlidesClasses();\n    if (params.effect !== 'slide') {\n      swiper.setTranslate(translate);\n    }\n    if (direction !== 'reset') {\n      swiper.transitionStart(runCallbacks, direction);\n      swiper.transitionEnd(runCallbacks, direction);\n    }\n    return false;\n  }\n  if (params.cssMode) {\n    const isH = swiper.isHorizontal();\n    if (speed === 0) {\n      wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;\n    } else {\n      // eslint-disable-next-line\n      if (wrapperEl.scrollTo) {\n        wrapperEl.scrollTo({\n          [isH ? 'left' : 'top']: -translate,\n          behavior: 'smooth',\n        });\n      } else {\n        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -translate;\n      }\n    }\n    return true;\n  }\n\n  if (speed === 0) {\n    swiper.setTransition(0);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    swiper.transitionEnd(runCallbacks, direction);\n  } else {\n    swiper.setTransition(speed);\n    swiper.setTranslate(translate);\n    swiper.updateActiveIndex(slideIndex);\n    swiper.updateSlidesClasses();\n    swiper.emit('beforeTransitionStart', speed, internal);\n    swiper.transitionStart(runCallbacks, direction);\n    if (!swiper.animating) {\n      swiper.animating = true;\n      if (!swiper.onSlideToWrapperTransitionEnd) {\n        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {\n          if (!swiper || swiper.destroyed) return;\n          if (e.target !== this) return;\n          swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n          swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n          swiper.onSlideToWrapperTransitionEnd = null;\n          delete swiper.onSlideToWrapperTransitionEnd;\n          swiper.transitionEnd(runCallbacks, direction);\n        };\n      }\n      swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);\n      swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);\n    }\n  }\n\n  return true;\n}\n"]},"metadata":{},"sourceType":"module"}